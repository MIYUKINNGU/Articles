<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <link rel="stylesheet" href="../index.css" type="text/css">
        <title>MIYUKINNGUの技術記事</title>
        <script type="text/javascript">MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:!0,autoload:{color:[],colorV2:['color']},packages:{'[+]':['noerrors']}},chtml:{scale: 1.2,matchFontHeight:!1,displayAlign:"left",displayIndent:"2em"},options:{renderActions:{find_script_mathtex:[10,function(doc){for(const node of document.querySelectorAll('script[type^="math/tex"]')){const display=!!node.type.match(/; *mode=display/);const math=new doc.options.MathItem(node.textContent,doc.inputJax[0],display);const text=document.createTextNode('');node.parentNode.replaceChild(text,node);math.start={node:text,delim:'',n:0};math.end={node:text,delim:'',n:0};doc.math.push(math)}},'']}},loader:{load:['[tex]/noerrors']}}</script>
        <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
    </head>
    <body>
        <div id="MathJax_Message" style="display: none;"></div>
        <header>
            MIYUKINNGUの技術記事
        </header>
        <main class="content">
            <div class="sideber-area">
                <ul>
                    <li><h2>目次</h2></li>
                    <li><a href="./index.html#introduction">はじめに(そして私事)</a></li>
                    <li><a href="./index.html#transform">まずは基本的なところから</a></li>
                    <li><a href="./index.html#movecamera">カメラを移動させてみよう</a></li>
                    <li><a href="./index.html#visualparamid">おや？描画の範囲外に行ったら様子がおかしいぞ...?</a></li>
                    <li><a href="./index.html#viewingangle">画角の変更方法</a></li>
                    <li><a href="./index.html#rotate">カメラを回転させてみよう</a></li>
                    <li><a href="./index.html#hiddenface">面を正しく描画してみよう</a></li>
                    <li><a href="./index.html#othertech">そのほかの技術</a></li>
                    <li><a href="./index.html#TryMaking">作成例</a></li>
                    <li><a href="./index.html#ref">参考文献等々</a></li>
                </ul>
            </div>
            <div class="main-content-area">
                <h1 class="page-title">3Dエンジンを作ってみよう</h1>
                <h2>対象読者</h2>
                <p>ScratchやJavaScript、C++等のGUIが問題なく使える言語で3Dエンジン(レンダラ)を作りたい人、作ってみたい人</p>
                <p>高校数学が十分に理解できている人(数ⅡBができていたら十分でしょう)</p>
                <h2 id="introduction">はじめに(そして私事)</h2>
                <p>最近作っている物と言えば何でしょうか...</p>
                <p>3Dレンダラですかね？理解すれば大して難しくなかったです。</p>
                <p>ということで今回は3Dレンダラを作ってみようというテーマで記事を書いていきたいと思います</p>
                <p>一応言っておきますが恐らくそう易々と理解できるものではないかと思います(特に回転等の計算)</p>
                <p>回転の項目についてはなんとなしで理解した方が良いかと...(自分もそうですし...)</p>
                <p>ってことで本題に入りましょうか</p>
                <h2 id="transform">まずは基本的なところから</h2>
                <p>さあ本題に入る、とはいってもまず何をすればよいのでしょうか？</p>
                <p>まあそれは結論を言ってしまえば三次元の物をどのようにしてスクリーンに写すか、ということです(この写す方法の事を投影方法と呼ぶ)</p>
                <p>これには自分の知る限りでは2種類の手法があり現在一番よく使われている方法は「<b>透視投影</b>」でしょう</p>
                <p>もう一方は「平行投影」と呼ばれる方法です。主にCADなどで使われる方法ですね。この投影方法は中学の技術でやったキャビネット図に相当します。</p>
                <p>ですが今回はあくまで透視投影です。透視投影は皆さんゲームをやっていたら100%目にします。</p>
                <p>そう、3Dゲームなどで使われる投影方法です。逆にこれ以外の投影方法となると広角レンズのような投影ができるゲームとかでしょうか...</p>
                <p>ですが大体ああいうのは視覚効果で行っており根本的な投影方法は同じだったりしますからね...</p>
                <p>I don't knowですな</p>
                <p>まあこのような投影方法で3Dをスクリーンに写すことができるというわけです</p>
                <p></p>
                <p>では早速その透視投影とやらをやってみようではないか</p>
                <p>透視投影をする方法は至ってシンプル。</p>
                <p>大前提はカメラの座標が原点にあることです。</p>
                <p>そしてメインのアルゴリズムは...</p>
                <p><b>空間上の点のx座標y座標それぞれをz座標で割る</b></p>
                <p>です。とてもシンプル。これは中学レベルの相似の考え方から導出することが可能です。暇ならやってみてください。</p>
                <p>ヒントはカメラの視線を底辺とする直角三角形で考える事でしょうか？</p>
                $$\left(x',y'\right)=\left(\frac{x}{z},\frac{y}{z}\right)$$
                <p>さて、これさえ理解してしまえば後は点同士を線でつなぐだけで3Dを描画できます。</p>
                <p>あら簡単。もう終わりですか？(※終わりではないです)</p>
                <h2 id="movecamera">カメラを移動させてみよう</h2>
                <p>さあ、こうなるとカメラを移動させたくなりますね。</p>
                <p>その方法はとても簡単ですが、少ししっかり考える必要があります。</p>
                <p>というのも、もし間違えてしまうと逆方向に動いてしまうからです。(まあ符号を修正すればいいだけなので大したことではないのですがね)</p>
                <p>カメラが動くとき、そのカメラからの相対的な位置関係としてはオブジェクトというのは必ずカメラの動く方向の逆方向に動きます。</p>
                <p>少しややこしいですね。とにかくカメラが固定されて動けなかったとしてもそう見せかけることは容易だということです</p>
                <p>これで先ほどの透視投影をする大前提を満たしますね。</p>
                <p>では式にしてみましょう。</p>
                <p>オブジェクトの移動量を$u=\left(a,b,c\right)$とし、カメラの移動量を$v=\left(p,q,r\right)$とする。($u,v$はどちらも3次元ベクトル)</p>
                <p>この時のカメラからの相対的な位置関係は</p>
                $$u-v=\left(a-p,b-q,c-r\right)$$
                <p>である</p>
                <p>終わりです。あとは先ほどの透視投影の式にこの式を入れれば移動については問題ありません。</p>
                <p>移動は各自で操作キーを割り当てていい感じに移動できるようにしてください。スライダー方式でも問題ないでしょう</p>
                <h2 id="visualparamid">おや？描画の範囲外に行ったら様子がおかしいぞ...?</h2>
                <p>ここまで読んで全て実践していたらおそらくこのことに気づいたでしょう。</p>
                <p>これを解決させる方法が存在します。それは視錐台の範囲に入ったら描画するというものです</p>
                <p>視錐台とは何でしょう？</p>
                <p>視錐台とはカメラの視点から見える範囲のことを指し、それがこたつのような形(これを錐台という)をしていることから来ています</p>
                <img src="./ViewTable.png">
                <p>視錐台の範囲に入ったことを確かめるためには直線の方程式からその範囲に入っていることを地道に確認するしかないです。</p>
                <p>そう、AND条件地獄です。数学の○$\lt x\lt$○とプログラミングは非常に相性が悪い...(Pythonでは謎に数学の時のように入力しても正しい評価になるが)</p>
                <p>直線の方程式は$ax+by+cz=d\left(a,b,c,d\in \mathbb{R}\right)$ですね。なので地道に比較するしかない...</p>
                <p>でも実は絶対値を使うと多少楽に作れる</p>
                <p>係数の値の決め方は画角から考える必要があります。ってことで次は画角の変更方法</p>
                <h2 id="viewingangle">画角の変更方法</h2>
                <p>ここまで来るとみんな画角が変更したくなるものです。(知らんけど)</p>
                <p>ということで画角を変更していきましょう</p>
                <p>やり方は比較的シンプルですが、三角関数を使うことになります。</p>
                <p>これについては画角を変更できるようにしたときに同時にDesmosでグラフ化させているので良ければぜひ見てみてください</p>
                <p><a href="https://www.desmos.com/calculator/vorrseafx8">画角と座標変換の式の関係 - desmos</a></p>
                <p>一応このグラフで注釈をすると$\cot\left(x\right)$は$\frac{1}{\tan\left(x\right)}$と等しいです。つまり$\tan\left(x\right)$の逆数ですね。(逆関数じゃあないよ！)</p>
                <p>導出はスクリーンの高さの1/2を直角三角形の高さとしたサインコサイン三角形の比で考えると良いでしょう</p>
                <p>$F_l$変数は焦点距離を求めています。焦点距離から調整しようというわけですね</p>
                <p>このグラフで式の関係も示されてるので話すことがないですね... 次に進みましょう。</p>
                <h2 id="rotate">カメラを回転させてみよう</h2>
                <p>さて回転です。カメラを回転させてみましょう。ここまで来たら回転もやりたいですねぇ</p>
                <p>ですが回転は大変です。今回は回転行列を使用せずにやってみたいと思います。</p>
                <p>回転行列は計算が大変なので実はちょっとよろしくない。そこでクォータニオンという回転方法を使っていきます。</p>
                <p>これのメリットは非常にたくさんあり、3Dの回転、姿勢を表すのに最も適していると思います。</p>
                <p>唯一のデメリットは保存される値を見てもどのような回転かがイメージしにくいことですね。</p>
                <p>ではクォータニオンとはいったい何なのでしょうか？</p>
                <p>クォータニオンとは数学的には複素数の拡張を行った物です</p>
                <details>
                    <summary>クォータニオン(四元数)の定義</summary>
                    <p>次の数$p$について次のように定義したとき</p>
                    $$p=w+xi+yj+zk\left(x,y,z,w\in\mathbb{R}\right)$$
                    <p>右辺の$i,j,k$が次の性質をもつならばこの$p$を<b>四元数</b>(<b>クォータニオン</b>,英: Quaternion)と呼ぶ</p>
                    $$i^2=j^2=k^2=ijk=-1$$
                    <p></p>
                </details>
                <p>プログラミングで複素数ってどうやって扱うねんって感じがしますがこれはベクトルに置き換えて考えることで実現させます</p>
                $$w+xi+yj+zk\rightarrow\left(x,y,z,w\right)$$
                <p>そしてそれぞれの値はどのように決めるのかというと、一番簡単なのは任意の軸からどのくらい回転したかを出す方法です</p>
                <p>任意の単位ベクトル$\vec{u}=\left(u_x,u_y,u_z\right)$を$\theta$回転させた際のクォータニオンへの変換は</p>
                $$
                x=u_x\sin\left(\frac{\theta}{2}\right)$$$$
                y=u_y\sin\left(\frac{\theta}{2}\right)$$$$
                z=u_z\sin\left(\frac{\theta}{2}\right)$$$$
                w=\cos\left(\frac{\theta}{2}\right)
                $$
                <p>です。さあこいつをどのようにして使うのでしょうか？その答えの前にまずクォータニオン同士の積を定義しておきましょう</p>
                <p>クォータニオン$p=\left(p_x,p_y,p_z,p_w\right),q=\left(q_x,q_y,q_z,q_w\right)$の積$q\times p$を次のように定義する</p>
                $$	
                \begin{eqnarray}
                q\times p&=&(q_wp_x-q_zp_y+q_yp_z+q_xp_w,\\&&q_zp_x+q_wp_y-q_xp_z+q_yp_w,\\&&-q_yp_x+q_xp_y+q_wp_z+q_zp_w,\\&&-q_xp_x-q_yp_y-q_zp_z+q_wp_w)	
                \end{eqnarray}
                $$
                <p><strong>※注意: 交換法則は成り立ちません</strong></p>
                <p>結論から言ってしまえば次のような計算をすることで原点からの座標点を回転させることができます。</p>
                $$
                q\times \vec{v}\times \bar{q}
                $$
                <p>($\bar{q}$は$q$の共役クォータニオン)</p>
                <p>これだけです。クォータニオンとベクトルの積はw要素を0としてベクトルをクォータニオンのように扱い、計算すれば可能です。(最終的にw要素は破棄します)</p>
                <p>特に回転行列に直したりだとかそういう必要はありません。このように計算するだけで回転後のベクトルをそのまま取得できます。</p>
                <p>なぜこのようになるかは自分の勉強不足で説明できません...(すまん)</p>
                <p>また、現在の回転の状態と新たな回転を加えて計算するという方法を取る場合は次のように計算すればいいです。</p>
                <p>現在の回転を$p$、新たに回転を加えるクォータニオンを$q$とすると、回転を加えた後のクォータニオンは$q\times p$である</p>
                <p>気を付けなければならないのは、新たに加える回転が先になるということです。</p>
                <p>これも同様にこの通り計算するだけで目的のものを得ることができます</p>
                <p>さて、先ほどから飛ばしていた共役クォータニオンについて説明しましょうか</p>
                <p>共役クォータニオンは単純に逆回転を示します。</p>
                <p>その逆回転の求め方は簡単。</p>
                <p>クォータニオンのw要素以外を負の数にするだけです。</p>
                <p>つまり、こういうこと。</p>
                $$
                \bar{q}=\left(-q_x,-q_y,-q_z,q_w\right)
                $$
                <p>簡単ですね。</p>
                <h2 id="hiddenface">面を正しく描画してみよう</h2>
                <p>面を正しく描画してみよう、ということで次は面を描画するのですが同じ色なら簡単ですね。</p>
                <p>ただ自由な四角形を塗るだけです。しかし！</p>
                <p>色が付いたりテクスチャが付いたりすると話は違う。</p>
                <p>隠れる面が何かを探さなければなりません！</p>
                <p>そのためにはどうしたらいいのでしょうか？</p>
                <p>それについて説明します。</p>
                <p>まず、隠れる面について考え、描画等の処理を行うことを<b>陰面処理</b>と言います</p>
                <p>この陰面処理をするには主に二つの方法が存在します。</p>
                <ul>
                    <li><p>Z-バッファ法</p></li>
                    <li><p>Z-ソート法</p></li>
                </ul>
                <p>この二つの方法の内、個人的にはZ-ソート法をお勧めしますが、もし半透明等の色を設定しないことを前提にするならZ-バッファ法の方が処理速度について圧倒的に速いです。</p>
                <p>というのも処理の仕方が違います。</p>
                <p>Z-ソート法は一番遠い点から描画していく方法。</p>
                <p>Z-バッファ法は一番近い点のみを描画する方法。</p>
                <p>それだけです。ちなみに最初は描画点ごとではなく描画面ごとで作るといいですよ</p>
                <p>描画点はかなり大変ですからね。実際面だけで考えた方が処理量も減りますしオブジェクト同士が重ならないなら描画面ごとでも遜色ないです。</p>
                <p>どちらも描画対象をソートしなければなりません。</p>
                <p>なのでソートアルゴリズムについて調べるいいと思います。</p>
                <p>これだけですね</p>
                <h2 id="othertech">そのほかの技術</h2>
                <p>ここで紹介した物以外にも様々な技術があります。</p>
                <p>大体ここで紹介してるのは自分が説明できない技術です。(やってなかったり理解できてなかったり...)</p>
                <p>*が付いたものは3D以外の場面でも使われます。</p>
                <ul>
                    <li><p>シェーディング</p></li>
                    <li><p>レイトレーシング</p></li>
                    <li><p>メタボール</p></li>
                    <li><p>球面回転補間</p></li>
                    <li><p>テクスチャマッピング</p></li>
                    <li><p>環境マッピング</p></li>
                    <li><p>グローバル・イルミネーション</p></li>
                    <li><p>フォトンマッピング</p></li>
                    <li><p>ブーリアン</p></li>
                    <li><p>アンチエイリアシング*</p></li>
                    <li><p>サブサーフェス・スキャタリング</p></li>
                    <li><p>異方性フィルタリング</p></li>
                    <li><p>ブルーム効果</p></li>
                    <li><p>モーションブラー*</p></li>
                    <li><p>ボリュームフォグ</p></li>
                </ul>
                <h2 id="TryMaking">作成例</h2>
                <p><b>操作方法</b></p>
                <ul>
                    <li><p>前進: W</p></li>
                    <li><p>後退: S</p></li>
                    <li><p>右移動: D</p></li>
                    <li><p>左移動: A</p></li>
                    <li><p>上移動: スペース</p></li>
                    <li><p>下移動: 左Shift</p></li>
                    <li><p>上回転: 上矢印</p></li>
                    <li><p>下回転: 下矢印</p></li>
                    <li><p>右回転: 右矢印</p></li>
                    <li><p>左回転: 左矢印</p></li>
                    <li><p>時計回り回転: M</p></li>
                    <li><p>反時計回り回転: N</p></li>
                </ul>
                <p>リセットボタン: <input type="button" value="Reset" title="Reset" onclick="Reset()"></p>
                <canvas id="3DProgram" width="640" height="480"></canvas>
                <script src="./3DProgram.js"></script>
                <h2 id="ref">参考文献等々</h2>
                <p><a href="https://ja.wikibooks.org/wiki/%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/3D%E3%82%B0%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF">ゲームプログラミング/3Dグラフィック - Wikibooks</a></p>
                <p><a href="https://qiita.com/drken/items/0639cf34cce14e8d58a5">クォータニオン (Quaternion) を総整理！ ～ 三次元物体の回転と姿勢を鮮やかに扱う ～ - Qiita</a></p>
                <p><a href="http://www.persfreaks.jp/main/math/basic/">3DCG - 数学 - パースフリークス</a></p>
            </div>
        </main>
    </body>
</html>